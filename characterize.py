import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig
import pickle as pkl
import argparse
from collections import defaultdict
import os, sys, csv


#############################################################
########################  Parameters  #######################
#############################################################
parser = argparse.ArgumentParser(description="""PlasRAG is a deep learning-based tool specifically designed for analyzing plasmids, which serves two purposes: (1) plasmid property characterization, and (2) plasmid DNA retrieval. Users can easily input their interested plasmid sequences. Then, PlasRAG can (1) describe the query plasmids with predicted properties and information from relevant literature, (2) retrieve eligible plasmids based on input property queries in Boolean expression form.""")
parser.add_argument('--query', help="question or instruction regarding the query plasmids, default: 'Please summarize key information from the most relevant literature.'", type=str, default='Please summarize key information from the most relevant literature.')
parser.add_argument('--out', help='path to store the prediction results, default: results', type=str, default='results')
parser.add_argument('--llm', help="whether to enable LLM for result summarization and question answering, default: 'True'", type=str, default="True")
parser.add_argument('--llama', help="the downloaded Llama3 model id, default: 'meta-llama/Llama-3.2-3B-Instruct'", type=str, default="meta-llama/Llama-3.2-3B-Instruct")
parser.add_argument('--quantize', help="whether to load the Llama-3 model in 8-bit or 4-bit, which can largely decrease memory usage ('False', '8bit', or '4bit'), default: 8bit", type=str, default='8bit')
parser.add_argument('--midfolder', help='the intermediate folder generated by preprocessing.py, default: ./temp', type=str, default='./temp')
parser.add_argument('--database', help='path of the PlasRAG database folder, default: ./database', type=str, default='./database')
parser.add_argument('--threads', help="number of threads utilized for prediction if 'cpu' is detected ('cuda' not found), default: 8", type=int, default=8)
inputs = parser.parse_args()


#############################################################
########################  Help info  ########################
#############################################################
def help_info():
    print('')
    print("""Usage of characterize.py:
        [--query QUERY] question or instruction regarding the query plasmids, default: 'Please summarize key information from the most relevant literature.'
        [--out OUT] path to store the prediction results, default: results
        [--llm LLM] whether to enable LLM for result summarization and question answering, default: 'True'
        [--llama LLAMA] the downloaded Llama3 model id, default: 'meta-llama/Llama-3.2-3B-Instruct'
        [--quantize QUANTIZE] whether to load the Llama-3 model in 8-bit or 4-bit, which can largely decrease memory usage ('False', '8bit', or '4bit'), default: '8bit'
        [--midfolder MIDFOLDER] the intermediate folder generated by preprocessing.py, default: ./temp
        [--database DATABASE] path of the PlasRAG database folder, default: ./database
        [--threads THREADS] number of threads utilized for prediction if 'cpu' is detected ('cuda' not found), default: 8
""")


db_path = inputs.database
out_fn = inputs.midfolder
id2pro = pkl.load(open(f'{db_path}/id2pro.dict', 'rb'))
lineage_dict = pkl.load(open(f'{db_path}/eco_lineage.dict', 'rb'))
level_dict = {0:'superkingdom', 1:'phylum', 2:'class', 3:'order', 4:'family', 5:'genus', 6:'species'}
pub_dict = pkl.load(open(f'{out_fn}/pub.dict', 'rb'))
question = inputs.query
res_fn = inputs.out
if not os.path.isdir(res_fn):
    os.makedirs(res_fn)


#############################################################
##################  Descriptive paragraph  ##################
#############################################################
def get_lowest(L):
    for level in ['genus', 'family', 'order', 'class']:
        for i,j in L:
            if(level in i):
                x, y = i[:i.find(' ')], i[i.find(' ')+1:]
                return y+' '+x
    L = [i for i,j in L]
    L = [i for i in L if 'phylum' in i]
    if(len(L)==1):
        return f"{L[0][L[0].find(' ')+1:]} phylum"
    else:
        X = []
        for i in L:
            X.append(i[i.find(' ')+1:])
        X = ', '.join(X)
        return 'multi-phyla '+X


def get_large(L):
    if(len(L)==1):
        return L[0][0]
    prob = -1
    ans = -1
    for i,j in L:
        if(j>prob):
            ans = i
            prob = j
    return ans


def ecohost(L):
    res = set()
    for level in ['species', 'genus', 'family', 'order', 'class', 'phylum', 'superkingdom']:
        X = [i for i in L if level in i]
        if(X==[]):
            continue
        for i in X:
            x = i[i.find(' ')+1:]
            res.add(i)
            for idx in range(len(lineage_dict[x])):
                taxon = f'{level_dict[idx]} {lineage_dict[x][idx]}'
                if(taxon in L):
                    L.remove(taxon)
    return res


def assemble(L, domain):
    if(domain=='vf'):
        if(L==[]):
            return 'The plasmid does not encode any virulence factors;' 
        vfs, categories = [], []
        for i,j in L:
            if(id2pro.inv[i][2]=='1'):
                categories.append(i)
            else:
                vfs.append(i)
        if(vfs!=[] and categories!=[]):
            x = f"The plasmid carries the virulence factor {', '.join(vfs)}, which belongs to the {', '.join(categories)} category;"
        elif(vfs!=[]):
            x = f"The plasmid carries the virulence factor {', '.join(vfs)};"
        elif(categories!=[]):
            x = f"The plasmid carries the virulence factor category {', '.join(categories)};"
        return x
    
    elif(domain=='metal'):
        if(L==[]):
            return 'The plasmid does not encode any metal resistance genes;'
        hmrs, metals = [], []
        for i,j in L:
            if(id2pro.inv[i][2]=='1'):
                metals.append(i[:i.rfind(' ')])
            else:
                hmrs.append(i[i.find('gene ')+5:])
        if(hmrs!=[] and metals!=[]):
            x = f"The plasmid encodes the metal resistance gene {', '.join(hmrs)}, which confer resistance to {', '.join(metals)};"
        elif(hmrs!=[]):
            x = f"The plasmid encodes the metal resistance gene {', '.join(hmrs)};"
        elif(metals!=[]):
            x = f"The plasmid encodes genes that confer resistance to {', '.join(metals)};"
        return x

    elif(domain=='inc'):
        if(L==[]):
            return 'The plasmid does not belong to any incompatibility groups;'
        incs = set()
        for i,j in L:
            inc = i[i.find('(')+1:i.rfind(', ')]
            incs.add(inc)
        incs = list(incs)
        return f"The plasmid belongs to the incompatibility group {', '.join(incs)};"

    elif(domain=='risk'):
        return f"The plasmid has a {L[-1][0]}, categorized as follows: 1) {L[0][0][:L[0][0].find(' ')]} risk based on insertion sequences, 2) {L[1][0][:L[1][0].find(' ')]} risk based on its distribution across habitats, 3) {L[2][0][:L[2][0].find(' ')]} based on virulence factor genes, 4) {L[3][0][:L[3][0].find(' ')]} based on all encoded ARGs, 5) {L[4][0][:L[4][0].find(' ')]} risk based on ARGs from WHO priority list, 6) {L[5][0][:L[5][0].find(' ')]} risk based on its host range breadth;"

    elif(domain=='host'):
        if(L==[]):
            return 'No host range information predicted for the plasmid;'
        x = get_lowest(L)        
        return f'The plasmid is hosted by bacteria in the {x};'

    elif(domain=='mob'):
        #x = [(i,j) for i,j in L if id2pro.inv[i][2]=='1']
        #mob1 = get_large(x)
        x = [i for i,j in L if id2pro.inv[i][2]=='6']
        if(x==[]):
            last = ''
        else:
            x = ', '.join(x)
            last = f' Additionally, it encodes {x} within the T4SS conjugation system;'
        x = [i for i,j in L if id2pro.inv[i][2] in ['4', '5']]
        if(x!=[]):
            mpfs = set()
            for i in x:
                mpfs.add(i[i.find('type ')+5:i.rfind(' (')])
            mpfs = ', '.join(list(mpfs))
            sentence=f'The plasmid is a conjugative plasmid, which encodes a complete conjugation system and belongs to the mating-pair-formation type {mpfs}.'
            return sentence+last 
        
        x = [i for i,j in L if id2pro.inv[i][2] in ['2', '3']]
        if(x!=[]):
            mobs = set()
            for i in x:
                mobs.add(i[i.find('type ')+5:i.rfind(' (')])
                mobs = ', '.join(list(mobs))
            sentence=f'The plasmid is a mobilizable plasmid, which belongs to mobilization type {mobs}.'
            return sentence+last
        
        return 'The plasmid is a non-mobilizable plasmid.'+last 
    
    elif(domain=='char'):
        sentence = ''
        x = [(i,j) for i,j in L if id2pro.inv[i] in ['CH2000', 'CH2003']]
        com = get_large(x)
        com = com[:com.rfind(' ')]
        x = [(i,j) for i,j in L if id2pro.inv[i] in ['CH2008', 'CH2009']]
        top = get_large(x)
        top = top[:top.rfind(' ')]
        sentence+=f'The plasmid is a {top}, {com}'
        x = [(i,j) for i,j in L if id2pro.inv[i]=='CH2007']
        if(x==[]):
            sentence+=' plasmid'
        else:
            sentence+=' phage-plasmid'
        x = [i for i,j in L if id2pro.inv[i] in ['CH2001', 'CH2002', 'CH2006']]
        if(x!=[]):
            x = ', '.join(x)
            sentence+=f' containing {x}'
        x = [i for i,j in L if id2pro.inv[i][2]=='1']
        if(x!=[]):
            x = ', '.join(x)
            sentence+=f', sourced from {x}'
        x = [(i,j) for i,j in L if id2pro.inv[i] in ['CH2004', 'CH2005']]
        if(x!=[]):
            gram = get_large(x)
            sentence+=f', and hosted by {gram}'
        sentence+='.'
        return sentence

    elif(domain=='amr'):
        if(L==[]):
            return 'The plasmid does not encode any ARGs;'
        sentence = []
        x = [i for i,j in L if id2pro.inv[i][2] in ['1', '4']]
        if(x!=[]):
            x = ', '.join(x)
            sentence.append(f'The plasmid encodes ARGs that confer resistance to {x}.')
        x = [i for i,j in L if id2pro.inv[i][2] in ['3']]
        if(x!=[]):
            x = ', '.join(x)
            sentence.append(f'The associated resistance mechanisms include {x}.')
        x = [i for i,j in L if id2pro.inv[i][2] in ['2']]
        if(x!=[]):
            x = ', '.join(x)
            sentence.append(f'Additionally, the plasmid encodes the ARG {x}, listed in the WHO priority list;')
        sentence = ' '.join(sentence)
        return sentence

    elif(domain=='eco'):
        if(L==[]):
            return 'No ecosystem information predicted for the plasmid;'
        sentence = []
        x = [i for i,j in L if id2pro.inv[i][:2]=='EH']
        if(x!=[]):
            hosts = ecohost(x)
            hosts = ', '.join(hosts)
            sentence.append(f'hosts of {hosts}')
        x = [i[i.find('habitat of')+11:-1]+' habitat' for i,j in L if id2pro.inv[i][:3]=='EC1']
        if(x!=[]):
            habitats = ', '.join(x)
            sentence.append(f'ecosystems associated with {habitats}')
        x = [i[i.find('the ')+4:i.rfind(' ecosystem')] for i,j in L if id2pro.inv[i][:3] in ['EC2', 'EC3']]
        if(x!=[]):
            ecos = ', '.join(x)
            sentence.append(f'{ecos} ecosystems')
        sentence = ', and '.join(sentence)
        return 'The plasmid can be found in '+sentence+'.'


res_dict = pkl.load(open(f'{out_fn}/res.dict', 'rb'))
descriptions = defaultdict(dict)
domains = {'eco':'Ecosystem', 'vf':'Virulence Factor', 'metal':'Metal Resistance', 'inc':'Incompatibility Group', 'risk':"Risk Index", 'host':'Host Range', 'mob':'Mobility', 'char':'Basic Properties', 'amr':'AMR'}
for pls in res_dict:
    tsv_w = csv.writer(open(f'{res_fn}/{pls}.tsv', 'w'), delimiter=',')
    tsv_w.writerow(['Item', 'Content'])
    for domain in ['amr', 'vf', 'metal', 'host', 'eco', 'mob', 'inc', 'risk', 'char']:
        if(domain!='eco'):
            L = res_dict[pls][domain]
        else:
            L = res_dict[pls]['eco']+res_dict[pls]['ecohost']
        description = assemble(L, domain)
        descriptions[pls][domain] = description
        tsv_w.writerow([domains[domain], description])
    tsv_w.writerow(['Reference plasmid', pub_dict[pls][0]])
    tsv_w.writerow(['Literature citation', pub_dict[pls][1]])
    tsv_w.writerow(['Literature abstract', pub_dict[pls][2]])

if(inputs.llm=='False'):
    print(f"All generated results have been saved in the '{res_fn}' folder (under non-LLM mode).")
    sys.exit()

#############################################################
##########################  Prompt  #########################
#############################################################
def generate_prompt(question, ref, abstract, description_dict):
    return f'''You are an expert in plasmid analysis (bioinformatics) tasked with providing insights based on genetic information.
    
    **Context**: We have analyzed a user-provided plasmid sequence and generated predictions regarding its properties from multiple facets. Additionally, we have identified the most relevant reference plasmid together with its associated literature abstract to support your answer.

    **User Question**: {question}

    **Predicted Properties**:
    - **AMR**: {description_dict['amr']}
    - **Virulence Factor**: {description_dict['vf']}
    - **Metal Resistance**: {description_dict['metal']}
    - **Host Range**: {description_dict['host']}
    - **Ecosystem**: {description_dict['eco']}
    - **Mobility**: {description_dict['mob']}
    - **Incompatibility Group**: {description_dict['inc']}
    - **Risk Index**: {description_dict['risk']}
    - **Basic Properties**: {description_dict['char']}

    **Retrieved Reference Plasmid**: {ref}

    **Literature Abstract**: {abstract}

    **Instructions**:
    1. Ensure that your answer is clear and directly addresses the user’s question, referencing the properties and literature as necessary when applicable.
    2. Ensure that your answer strictly utilizes the details given and avoids any generation of additional information or hallucinations.
    3. Avoid including simple information such as sequence length, gene count, or other basic metrics.
    4. When analyzing the literature, summarize key information about the reference {ref} based on the abstract. Focus on specific functions, resistance characteristics, clinical significance, and mechanisms of action.
    '''

#input_text = []
#plasmids = []
prompt_dict = {}
for pls in descriptions:
    ref, citation, abstract = pub_dict[pls]
    description_dict = descriptions[pls]
    prompt = generate_prompt(question, ref, abstract, description_dict)    
    #input_text.append(prompt)
    #plasmids.append(pls)
    prompt_dict[pls] = prompt


#############################################################
#########################  Run LLM  #########################
#############################################################
llm = inputs.llama
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
if device == torch.device('cpu'):
    torch.set_num_threads(inputs.threads)
    print(f"Running with CPU {inputs.threads} threads ...")
else:
    print(f"Running with GPU ...")
tokenizer = AutoTokenizer.from_pretrained(llm)

if(inputs.quantize=='False'):
    model = AutoModelForCausalLM.from_pretrained(llm).to(device)
    print('Load full model ...')
elif(inputs.quantize=='8bit'):
    print('Load quantized model in 8-bit mode ...')
    quantization_config = BitsAndBytesConfig(load_in_8bit=True)
    model = AutoModelForCausalLM.from_pretrained(llm, device_map=device, torch_dtype=torch.bfloat16, quantization_config=quantization_config)
elif(inputs.quantize=='4bit'):
    quantization_config = BitsAndBytesConfig(load_in_4bit=True)
    model = AutoModelForCausalLM.from_pretrained(llm, device_map=device, torch_dtype=torch.bfloat16, quantization_config=quantization_config)
    print('Load quantized model in 4-bit mode ...')

for pls in prompt_dict:
    tsv_w = csv.writer(open(f'{res_fn}/{pls}_ans.tsv', 'w'), delimiter=',')
    tsv_w.writerow(['Item', 'Content'])
    input_text = prompt_dict[pls]
    input_ids = tokenizer(input_text, return_tensors="pt").to(device)
    original_len = len(input_ids.input_ids[0])
    output = model.generate(**input_ids, temperature=0.3, max_new_tokens=original_len+250)
    output = output[0][original_len:]
    ans = tokenizer.decode(output, skip_special_tokens=True)
    tsv_w.writerow(['Question', question])
    tsv_w.writerow(['Answer', ans])
print(f"All generated results have been saved in the '{res_fn}' folder (under LLM mode).")
